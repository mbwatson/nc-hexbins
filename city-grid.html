<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>nc cities</title>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <style>
        svg {
            border: 1px solid #ccc;
            padding: 1rem;
        }
        .state {
            fill: darkcyan;
            stroke: black;
            stroke-width: 1;
        }
        .tile {
            fill: lightcoral;
            stroke: black;
            stroke-width: 1;
            transition: filter 750ms;
        }
        .tile:hover {
            filter: brightness(0.5);
            transition: filter 250ms;
        }
    </style>
</head>
<body>
    <script>
        const STATEFILE = './data/nc.json'
        const CITIESFILE = './data/cities.json'
        const MARGIN = 16

        const WIDTH = 960
        const HEIGHT = 500
        
        let projection = d3.geoMercator()
        let geoPath

        const svg = d3.select('body')
            .append('svg')
            .attr("viewBox", [0, 0, WIDTH, HEIGHT])
            .attr('width', WIDTH)
            .attr('height', HEIGHT)

        const stateGroup = svg.append('g').attr('class', 'states')
        const tilesGroup = svg.append('g').attr('class', 'tiles')

        Promise.all([
            d3.json(STATEFILE),
            d3.json(CITIESFILE),
        ]).then(([state, cities]) => {
            projection.fitSize([WIDTH, HEIGHT], state) // choose & modify a projection
            geoPath = d3.geoPath().projection(projection) // create path generator initialized with the defined projection
            
            stateGroup.selectAll('path')
                .data(state.features).enter()
                .append('path').attr('class', 'state')
                .attr('d', d => geoPath(d))
            
            let [[lonMin, latMin], [lonMax, latMax]] = d3.geoBounds(state)

            const tiles = {
                type: 'FeatureCollection',
                features: []
            }

            const STEP = 0.2
            for (let lat = latMin; lat < latMax; lat += STEP) {
                for (let lon = lonMin; lon < lonMax; lon += STEP) {
                    const tile = {
                        type: 'Feature',
                        properties: {
                            id: `${ lon }-${ lat }`,
                            count: 0,
                            midpoint: [lon + STEP / 2, lat + STEP / 2],
                        },
                        geometry: {
                            type: 'Polygon',
                            coordinates: [[
                                [lon, lat],
                                [lon, lat + STEP],
                                [lon + STEP, lat + STEP],
                                [lon + STEP, lat],
                                [lon, lat],
                            ]],
                        },
                    }
                    tiles.features.push(tile)
                }
            }
            const tileCovering = tiles.features.filter(tile => d3.geoContains(state, tile.properties.midpoint))
            tilesGroup.selectAll('.tile')
                .data(tileCovering).enter()
                .append('path').attr('class', 'tile')
                .attr('d', d => geoPath(d))
        })

    </script>
</body>
</html>